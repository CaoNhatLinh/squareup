const admin = require('firebase-admin');const crypto = require('crypto');const db = admin.database();const { sendInvitationEmail } = require('../utils/emailService');const { invitation } = require('../config/cleanup.config');const INVITATION_EXPIRY_TIME = invitation.EXPIRY_TIME;async function getStaffMembers(req, res) {  const { restaurantId } = req.params;  const page = parseInt(req.query.page, 10) || 1;  const limit = parseInt(req.query.limit, 10) || 25;  const q = (req.query.q || '').toLowerCase().trim();  const sortBy = req.query.sortBy || 'displayName';  const sortDir = (req.query.sortDir || 'asc').toLowerCase();  try {    const staffRef = db.ref(`restaurants/${restaurantId}/staff`);    const snapshot = await staffRef.get();    if (!snapshot.exists()) {      return res.json({ success: true, data: [], meta: { total: 0, limit, page } });    }    let staffList = [];    snapshot.forEach((child) => {      staffList.push({ id: child.key, ...child.val() });    });    if (q) {      staffList = staffList.filter(s => (s.displayName || '').toLowerCase().includes(q) || (s.email || '').toLowerCase().includes(q));    }    if (sortBy) {      const dir = sortDir === 'asc' ? 1 : -1;      staffList = staffList.sort((a, b) => {        const va = (a[sortBy] || '').toString().toLowerCase();        const vb = (b[sortBy] || '').toString().toLowerCase();        if (va < vb) return -1 * dir;        if (va > vb) return 1 * dir;        return 0;      });    }    const total = staffList.length;    const startIndex = Math.max((page - 1) * limit, 0);    const endIndex = startIndex + limit;    const paged = staffList.slice(startIndex, endIndex);    return res.json({ success: true, data: paged, meta: { total, page, limit } });  } catch (error) {    console.error('getStaffMembers error:', error);    return res.status(500).json({ error: 'Server error' });  }}async function inviteStaff(req, res) {  const { restaurantId } = req.params;  const { email, roleId } = req.body;  if (!restaurantId) {    console.error('inviteStaff: missing restaurantId in params');    return res.status(400).json({ error: 'restaurantId is required in the URL' });  }  if (!email || !roleId) {    return res.status(400).json({ error: 'Email and roleId are required' });  }  try {    const roleSnapshot = await db.ref(`restaurants/${restaurantId}/roles/${roleId}`).get();    if (!roleSnapshot.exists()) {      return res.status(404).json({ error: 'Role not found' });    }    const staffSnapshot = await db.ref(`restaurants/${restaurantId}/staff`)      .orderByChild('email')      .equalTo(email)      .get();    if (staffSnapshot.exists()) {      let existingStaff = null;      staffSnapshot.forEach((child) => {        existingStaff = child.val();      });      return res.status(400).json({        error: `${email} is already a staff member with role: ${existingStaff.roleName || 'Unknown'}. Cannot send invitation.`,        type: 'already_staff'      });    }    const invitationsSnapshot = await db.ref(`invitations`)      .orderByChild('email')      .equalTo(email)      .get();    let existingInvitation = null;    invitationsSnapshot.forEach((child) => {      const inv = child.val();      if (inv.restaurantId === restaurantId && inv.status === 'pending') {        existingInvitation = { id: child.key, ...inv };      }    });    if (existingInvitation) {      const minutesRemaining = Math.floor((existingInvitation.expiresAt - Date.now()) / 1000 / 60);      return res.status(400).json({        error: `There is already a pending invitation for ${email}. It will expire in ${minutesRemaining} minutes. You can resend or cancel it from the pending invitations list.`,        type: 'pending_invitation',        invitationId: existingInvitation.id,        expiresIn: minutesRemaining      });    }    const token = crypto.randomBytes(32).toString('hex');    const expiresAt = Date.now() + INVITATION_EXPIRY_TIME;    const restaurantSnapshot = await db.ref(`restaurants/${restaurantId}`).get();    const restaurantData = restaurantSnapshot.val();    const roleData = roleSnapshot.val();    const invitationRef = db.ref('invitations').push();    const invitationData = {      email,      restaurantId,      restaurantName: restaurantData?.name || 'Restaurant',      roleId,      roleName: roleData?.name || 'Staff',      token,      status: 'pending',      createdAt: Date.now(),      expiresAt,      invitedBy: req.user.uid,    };    await invitationRef.set(invitationData);    const invitationLink = `${process.env.CLIENT_URL}/accept-invitation?token=${token}`;    const emailResult = await sendInvitationEmail(      email,      restaurantData?.name || 'Restaurant',      invitationLink,      roleData?.name || 'Staff'    );    return res.status(201).json({ success: true, data: { invitation: { id: invitationRef.key, ...invitationData }, emailSent: emailResult.success, token } });  } catch (error) {    console.error('inviteStaff error:', error);    return res.status(500).json({ error: 'Server error' });  }}async function getInvitation(req, res) {  const { token } = req.params;  try {    const snapshot = await db.ref('invitations')      .orderByChild('token')      .equalTo(token)      .get();    if (!snapshot.exists()) {      return res.status(404).json({ error: 'Invitation not found' });    }    let invitation = null;    snapshot.forEach((child) => {      invitation = { id: child.key, ...child.val() };    });    if (invitation.status !== 'pending') {      return res.status(400).json({ error: 'This invitation has already been used' });    }    if (invitation.expiresAt < Date.now()) {      return res.status(400).json({ error: 'This invitation has expired' });    }    const roleSnapshot = await db.ref(`restaurants/${invitation.restaurantId}/roles/${invitation.roleId}`).get();    const role = roleSnapshot.exists() ? roleSnapshot.val() : null;    return res.json({ success: true, data: { invitation: { ...invitation, role } } });  } catch (error) {    console.error('getInvitation error:', error);    return res.status(500).json({ error: 'Server error' });  }}async function acceptInvitation(req, res) {  const { token, password, displayName } = req.body;  if (!token) {    return res.status(400).json({ error: 'Token is required' });  }  try {    const snapshot = await db.ref('invitations')      .orderByChild('token')      .equalTo(token)      .get();    if (!snapshot.exists()) {      return res.status(404).json({ error: 'Invitation not found' });    }    let invitationId = null;    let invitation = null;    snapshot.forEach((child) => {      invitationId = child.key;      invitation = child.val();    });    if (invitation.status !== 'pending') {      return res.status(400).json({ error: 'This invitation has already been used' });    }    if (invitation.expiresAt < Date.now()) {      return res.status(400).json({ error: 'This invitation has expired' });    }    let userRecord = null;    let isExistingUser = false;    if (req.user) {      if (req.user.email !== invitation.email) {        return res.status(403).json({ error: 'This invitation is for a different email address' });      }      userRecord = req.user;      isExistingUser = true;    } else {      try {        userRecord = await admin.auth().getUserByEmail(invitation.email);        return res.status(400).json({          error: 'An account with this email already exists. Please sign in to accept the invitation.'        });      } catch (error) {        if (!password || !displayName) {          return res.status(400).json({ error: 'Password and displayName are required for new users' });        }        userRecord = await admin.auth().createUser({          email: invitation.email,          password,          displayName,          emailVerified: true,        });        await admin.auth().setCustomUserClaims(userRecord.uid, {          role: 'staff',          restaurantId: invitation.restaurantId,        });        await db.ref(`users/${userRecord.uid}`).set({          email: invitation.email,          displayName,          role: 'staff',          restaurantId: invitation.restaurantId,          createdAt: Date.now(),        });      }    }    await db.ref(`users/${userRecord.uid}/restaurants/${invitation.restaurantId}`).set({      name: invitation.restaurantName || 'Restaurant',      role: 'staff',      createdAt: Date.now(),      active: true,    });    await db.ref(`restaurants/${invitation.restaurantId}/staff/${userRecord.uid}`).set({      email: invitation.email,      displayName: userRecord.displayName || displayName,      roleId: invitation.roleId,      joinedAt: Date.now(),    });    await db.ref(`invitations/${invitationId}`).update({      status: 'accepted',      acceptedAt: Date.now(),      userId: userRecord.uid,    });    return res.status(isExistingUser ? 200 : 201).json({      success: true,      data: {        message: isExistingUser ? 'Invitation accepted successfully' : 'Account created successfully',        user: {          uid: userRecord.uid,          email: userRecord.email || invitation.email,          displayName: userRecord.displayName || displayName        }      }    });  } catch (error) {    console.error('acceptInvitation error:', error);    return res.status(500).json({ error: 'Server error' });  }}async function removeStaff(req, res) {  const { restaurantId, staffId } = req.params;  try {    const staffSnapshot = await db.ref(`restaurants/${restaurantId}/staff/${staffId}`).get();    if (!staffSnapshot.exists()) {      return res.status(404).json({ error: 'Staff member not found' });    }    await db.ref(`restaurants/${restaurantId}/staff/${staffId}`).remove();    return res.json({ success: true, data: { message: 'Staff member removed successfully' } });  } catch (error) {    console.error('removeStaff error:', error);    return res.status(500).json({ error: 'Server error' });  }}async function updateStaffRole(req, res) {  const { restaurantId, staffId } = req.params;  const { roleId } = req.body;  if (!roleId) {    return res.status(400).json({ error: 'RoleId is required' });  }  try {    const roleSnapshot = await db.ref(`restaurants/${restaurantId}/roles/${roleId}`).get();    if (!roleSnapshot.exists()) {      return res.status(404).json({ error: 'Role not found' });    }    const staffSnapshot = await db.ref(`restaurants/${restaurantId}/staff/${staffId}`).get();    if (!staffSnapshot.exists()) {      return res.status(404).json({ error: 'Staff member not found' });    }    await db.ref(`restaurants/${restaurantId}/staff/${staffId}`).update({      roleId,      updatedAt: Date.now(),    });    return res.json({ success: true, data: { message: 'Staff role updated successfully' } });  } catch (error) {    console.error('updateStaffRole error:', error);    return res.status(500).json({ error: 'Server error' });  }}async function resendInvitation(req, res) {  const { invitationId } = req.params;  try {    const snapshot = await db.ref(`invitations/${invitationId}`).get();    if (!snapshot.exists()) {      return res.status(404).json({ error: 'Invitation not found' });    }    const invitation = snapshot.val();    if (invitation.status !== 'pending') {      return res.status(400).json({ error: 'Cannot resend accepted or expired invitations' });    }    const token = crypto.randomBytes(32).toString('hex');    const expiresAt = Date.now() + INVITATION_EXPIRY_TIME;    await db.ref(`invitations/${invitationId}`).update({      token,      expiresAt,      updatedAt: Date.now(),    });    const invitationLink = `${process.env.CLIENT_URL}/accept-invitation?token=${token}`;    const emailResult = await sendInvitationEmail(      invitation.email,      invitation.restaurantName,      invitationLink,      invitation.roleName    );    return res.json({ success: true, data: { message: 'Invitation resent successfully', emailSent: emailResult.success, token } });  } catch (error) {    console.error('resendInvitation error:', error);    return res.status(500).json({ error: 'Server error' });  }}async function getPendingInvitations(req, res) {  const { restaurantId } = req.params;  try {    const snapshot = await db.ref('invitations')      .orderByChild('restaurantId')      .equalTo(restaurantId)      .get();    if (!snapshot.exists()) {      return res.json({ success: true, data: [] });    }    const invitations = [];    snapshot.forEach((child) => {      const invitation = child.val();      if (invitation.status === 'pending') {        invitations.push({          id: child.key,          ...invitation,        });      }    });    invitations.sort((a, b) => b.createdAt - a.createdAt);    return res.json({ success: true, data: invitations });  } catch (error) {    console.error('getPendingInvitations error:', error);    return res.status(500).json({ error: 'Server error' });  }}async function cancelInvitation(req, res) {  const { restaurantId, invitationId } = req.params;  try {    const snapshot = await db.ref(`invitations/${invitationId}`).get();    if (!snapshot.exists()) {      return res.status(404).json({        error: 'Invitation not found',        type: 'not_found'      });    }    const invitation = snapshot.val();    if (invitation.restaurantId !== restaurantId) {      return res.status(403).json({        error: 'Unauthorized',        type: 'unauthorized'      });    }    if (invitation.status !== 'pending') {      const statusMessages = {        'accepted': `This invitation has already been accepted by the user. They are now a staff member.`,        'expired': `This invitation has expired and cannot be cancelled. It expired at ${new Date(invitation.expiredAt).toLocaleString('vi-VN')}.`,        'cancelled': `This invitation was already cancelled at ${new Date(invitation.cancelledAt).toLocaleString('vi-VN')}.`      };      return res.status(400).json({        error: statusMessages[invitation.status] || 'Can only cancel pending invitations',        type: 'invalid_status',        currentStatus: invitation.status,        statusChangedAt: invitation.acceptedAt || invitation.expiredAt || invitation.cancelledAt      });    }    if (invitation.expiresAt && invitation.expiresAt < Date.now()) {      return res.status(400).json({        error: 'This invitation has just expired and cannot be cancelled.',        type: 'just_expired',        expiredAt: invitation.expiresAt      });    }    await db.ref(`invitations/${invitationId}`).update({      status: 'cancelled',      cancelledAt: Date.now(),      cancelledBy: req.user.uid,    });    return res.json({      success: true,      data: { message: 'Invitation cancelled successfully' }    });  } catch (error) {    console.error('cancelInvitation error:', error);    return res.status(500).json({ error: 'Server error' });  }}async function getAllInvitations(req, res) {  const { restaurantId } = req.params;  const page = parseInt(req.query.page, 10) || 1;  const limit = parseInt(req.query.limit, 10) || 25;  const status = req.query.status || 'all';   const sortBy = req.query.sortBy || 'createdAt';  const sortDir = (req.query.sortDir || 'desc').toLowerCase();  try {    const snapshot = await db.ref('invitations')      .orderByChild('restaurantId')      .equalTo(restaurantId)      .get();    if (!snapshot.exists()) {      return res.json({        success: true,        data: [],        meta: { total: 0, page, limit }      });    }    let invitations = [];    snapshot.forEach((child) => {      const invitation = child.val();      invitations.push({        id: child.key,        ...invitation,      });    });    if (status !== 'all') {      invitations = invitations.filter(inv => inv.status === status);    }    const dir = sortDir === 'asc' ? 1 : -1;    invitations.sort((a, b) => {      const valA = a[sortBy] || 0;      const valB = b[sortBy] || 0;      if (valA < valB) return -1 * dir;      if (valA > valB) return 1 * dir;      return 0;    });    const total = invitations.length;    const startIndex = (page - 1) * limit;    const endIndex = startIndex + limit;    const paged = invitations.slice(startIndex, endIndex);    return res.json({      success: true,      data: paged,      meta: {        total,        page,        limit,        totalPages: Math.ceil(total / limit),        status,        sortBy,        sortDir      }    });  } catch (error) {    console.error('getAllInvitations error:', error);    return res.status(500).json({ error: 'Server error' });  }}module.exports = {  getStaffMembers,  inviteStaff,  getInvitation,  acceptInvitation,  removeStaff,  updateStaffRole,  resendInvitation,  getPendingInvitations,  cancelInvitation,  getAllInvitations,};